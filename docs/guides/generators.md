# Generator Pattern

Generators should be thin — just wiring between the Projection and Writer layers. All examples in this guide are drawn from the [Deepstaging](https://github.com/deepstaging/deepstaging) source generator suite.

## The Thin Generator

A generator's `Initialize` method does three things:

1. **Select** symbols via `ForAttribute<T>()`
2. **Project** them into models via the Projection layer
3. **Emit** code via Writer extension methods

```csharp
[Generator]
public sealed class StrongIdGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var models = context.ForAttribute<StrongIdAttribute>()
            .Map(static (ctx, _) => ctx.TargetSymbol
                .AsValidNamedType()
                .ToStrongIdModel(ctx.SemanticModel));

        context.RegisterSourceOutput(models, static (ctx, model) =>
        {
            model.WriteStrongId()
                .AddSourceTo(ctx, HintName.From(model.Namespace, model.TypeName));
        });
    }
}
```

That's the entire generator — 14 lines. The complexity lives in the Projection layer (model construction) and the Writer (code emission).

### Multiple Pipelines

When a generator drives multiple features, register separate pipelines:

```csharp
[Generator]
public sealed class EffectsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Pipeline 1: Runtime classes
        var runtimes = context.ForAttribute<RuntimeAttribute>()
            .Map(static (ctx, _) => ctx.TargetSymbol
                .AsValidNamedType()
                .QueryRuntimeModel());

        context.RegisterSourceOutput(runtimes, static (ctx, model) =>
        {
            model.WriteRuntimeClass()
                .AddSourceTo(ctx, HintName.From(model.Namespace, model.TypeName));
            model.WriteRuntimeBootstrapperClass()
                .AddSourceTo(ctx, HintName.From(model.Namespace, $"{model.TypeName}Bootstrapper"));
            model.WriteRuntimeCapabilitiesInterface()
                .AddSourceTo(ctx, HintName.From(model.Namespace, $"I{model.TypeName}Capabilities"));
        });

        // Pipeline 2: Effects modules
        var modules = context.ForAttribute<EffectsModuleAttribute>()
            .Map(static (ctx, _) => ctx.TargetSymbol
                .AsValidNamedType()
                .QueryEffectsModules());

        context.RegisterSourceOutput(modules, static (ctx, models) =>
        {
            foreach (var model in models)
            {
                model.WriteEffectsModule()
                    .AddSourceTo(ctx, HintName.From(model.Namespace, model.TypeName));
            }
        });
    }
}
```

### Static Output with Post-Initialization

Use `RegisterPostInitializationOutput` for code that doesn't depend on user source:

```csharp
[Generator]
public sealed class PreludeGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static ctx =>
        {
            ctx.AddSource("Prelude.g.cs", """
                // <auto-generated/>
                global using LanguageExt;
                global using LanguageExt.Common;
                global using static LanguageExt.Prelude;
                """);
        });
    }
}
```

## Writer Classes

Writers are extension methods on model types that return `OptionalEmit`. They live in `Writers/` subdirectories, organized by domain.

### Basic Writer

```csharp
// Writers/Ids/StrongIdWriter.cs
extension(StrongIdModel model)
{
    public OptionalEmit WriteStrongId()
    {
        var backingType = model.BackingTypeSnapshot;
        var valueProperty = PropertyBuilder
            .Parse($"public {backingType.FullyQualifiedName} Value {{ get; }}");

        return TypeBuilder
            .Parse($"{model.Accessibility} partial struct {model.TypeName}")
            .InNamespace(model.Namespace)
            .AddProperty(valueProperty)
            .AddConstructor(model)
            .ImplementsIEquatable(backingType, valueProperty)
            .ImplementsIComparable(backingType, valueProperty)
            .OverridesToString(
                model.BackingType == BackingType.String
                    ? $"{valueProperty.Name} ?? \"\""
                    : $"{valueProperty.Name}.ToString()",
                true)
            .AddFactoryMethods(model)
            .AddConverters(model, valueProperty)
            .Emit();
    }
}
```

!!! note "Why OptionalEmit?"
    `Emit()` returns `OptionalEmit` which safely handles null models. The `AddSourceTo` extension only emits when the result is valid.

### Composition with WithEach and If

Writers compose complex output using `WithEach` for collections and `If` for conditional sections:

```csharp
extension(EffectsModuleModel model)
{
    public OptionalEmit WriteEffectsModule() => TypeBuilder
        .Parse($"public static partial class {model.TypeName}")
        .InNamespace(model.Namespace)
        .WithEach(model.Methods, WriteEffectMethod)
        .If(model.HasDbContext, b => b.AddDbSetQueries(model))
        .Emit();

    static TypeBuilder WriteEffectMethod(TypeBuilder builder, EffectMethodModel method) =>
        builder.AddMethod(MethodBuilder
            .Parse($"public static Eff<RT, {method.ReturnType}> {method.Name}<RT>()")
            .WithTypeConstraint("RT", model.ConstraintInterface)
            .WithBody(b => b
                .AddStatement(method.IsAsync
                    ? EffExpression.LiftIO().Async($"rt => rt.{model.PropertyName}.{method.Name}()")
                    : EffExpression.Lift().Sync($"rt => rt.{model.PropertyName}.{method.Name}()"))));
}
```

### Delegating to Sub-Writers

For complex types, break the writer into focused helper methods:

```csharp
extension(StrongIdModel model)
{
    public OptionalEmit WriteStrongId() => TypeBuilder
        .Parse($"{model.Accessibility} partial struct {model.TypeName}")
        .InNamespace(model.Namespace)
        .AddProperty(valueProperty)
        .AddConstructor(model)

        // Interface implementations — each is a separate extension method
        .ImplementsIEquatable(backingType, valueProperty)
        .ImplementsIComparable(backingType, valueProperty)
        .ImplementsIParsable(backingType)

        // Converters — conditionally added based on flags
        .AddConverters(model, valueProperty)
        .Emit();
}
```

Each `.ImplementsIEquatable()`, `.AddConverters()`, etc. is its own extension method on `TypeBuilder`, keeping each piece focused and testable.

## Emit Best Practices

### Parse for Complex Signatures

When a method or property has a non-trivial signature, use `Parse` instead of building piece by piece:

```csharp
// Clear and readable
MethodBuilder.Parse("public static Eff<RT, Option<Attendee>> GetById<RT>(AttendeeId id)")
    .WithTypeConstraint("RT", "IHasWorkshopDb")
    .WithBody(b => b.AddStatement("..."));
```

### Use TypeRef for Type-Safe References

```csharp
// Type-safe wrappers — no magic strings
var returnType = new TaskTypeRef(TypeRef.Global("System.Collections.Generic.IReadOnlyList<Customer>"));
// Produces: Task<IReadOnlyList<Customer>>
```

### Use Patterns for Common Implementations

The Emit layer includes pre-built pattern methods for common interface implementations:

```csharp
TypeBuilder.Struct("OrderId")
    .ImplementsIEquatable(backingType, valueProperty)  // Equals, GetHashCode, ==, !=
    .ImplementsIComparable(backingType, valueProperty)  // CompareTo, <, >, <=, >=
    .ImplementsIParsable(backingType)                   // Parse, TryParse
    .ImplementsIFormattable(backingType, valueProperty) // ToString(format, provider)
    .Emit();
```
