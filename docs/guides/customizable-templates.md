# Customizable Templates

Make your generator's output customizable by consumers through Scriban templates.

## Overview

When a generator uses **customizable templates**, consumers can override the default generated code by providing their own `.scriban-cs` template files. The flow:

```
Generator Author                          Consumer
─────────────────                         ────────
model.WriteMyType(map)                    Templates/MyProject/MyType.scriban-cs
  → OptionalEmit (default code)             → User-provided Scriban template
  → .WithUserTemplate(name, model, map)     → {{ TypeName }}, {{ Namespace }}, etc.
  → .AddSourceTo(ctx, hint, templates)      → Rendered C# replaces default
```

If no user template exists, the default emit is used unchanged.

## Generator Author Guide

### 1. Create a TemplateMap

A `TemplateMap<T>` tracks which model property values are used in the emit, creating a mapping between model properties and the code they produce.

```csharp
var map = new TemplateMap<MyModel>();

TypeBuilder.Class(map.Bind(model.Name, m => m.Name))
    .InNamespace(map.Bind(model.Namespace, m => m.Namespace))
    .AddProperty("Value", map.Bind(model.ValueType, m => m.ValueType))
    .Emit();
```

`Bind` is a **pass-through** — it returns the value unchanged but records the mapping. The expression `m => m.Name` extracts the property path, which becomes a Scriban placeholder (`{{ Name }}`).

!!! tip "Nested properties"
    `Bind` supports nested access: `map.Bind(model.Type.CodeName, m => m.Type.CodeName)` produces the placeholder `{{ Type.CodeName }}`.

### 2. Define the user template

Chain `.WithUserTemplate()` after `.Emit()` to create a `CustomizableEmit`:

```csharp
model.WriteMyType(map)                      // → OptionalEmit
    .WithUserTemplate("MyProject/MyType",   // template name
                      model,                // model for rendering
                      map)                  // bindings for scaffolding
    .AddSourceTo(ctx, hintName, templates); // resolve + emit
```

The **template name** uses a `Project/Type` convention (e.g., `Deepstaging.Ids/StrongId`). This maps to the file path `Templates/Deepstaging.Ids/StrongId.scriban-cs` in the consumer's project.

### 3. Wire the generator pipeline

Use `UserTemplatesProvider` to discover templates from `AdditionalTexts`:

```csharp
[Generator]
public sealed class MyGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var userTemplates = context.UserTemplatesProvider;

        var models = context.ForAttribute<MyAttribute>()
            .Map(static (ctx, _) => /* projection */);

        context.RegisterSourceOutput(
            models.Combine(userTemplates),
            static (ctx, pair) =>
            {
                var (model, templates) = pair;
                var map = new TemplateMap<MyModel>();

                model.WriteMyType(map)
                    .WithUserTemplate("MyProject/MyType", model, map)
                    .AddSourceTo(ctx, hintName, templates);
            });
    }
}
```

### 4. Emit scaffold metadata

Add a second pipeline that emits `AssemblyMetadata` attributes advertising the customizable template. This enables the [scaffold analyzer and code fix](#scaffold-analyzer).

```csharp
// Once: emit scaffold from first model
context.RegisterSourceOutput(
    models.Collect().Select(static (m, _) => m.Length > 0 ? m[0] : default),
    static (ctx, model) =>
    {
        if (model is null) return;

        var map = new TemplateMap<MyModel>();
        var customizable = model.WriteMyType(map)
            .WithUserTemplate("MyProject/MyType", model, map);

        ScaffoldEmitter.EmitScaffold(ctx, customizable,
            "MyProject.MyAttribute");  // trigger attribute FQN
    });
```

## Consumer Guide

### Creating a user template

Add a `.scriban-cs` file in the `Templates/` directory of your project:

```
MyApp/
├── MyApp.csproj
└── Templates/
    └── Deepstaging.Ids/
        └── StrongId.scriban-cs
```

The template uses [Scriban](https://github.com/scriban/scriban) syntax with the model properties as placeholders:

```scriban
// <auto-generated/>
#nullable enable

namespace MyApp;

public readonly partial struct {{ TypeName }} : IEquatable<{{ TypeName }}>
{
    public System.Guid Value { get; }

    public {{ TypeName }}(System.Guid value) => Value = value;

    // Custom: add a factory method
    public static {{ TypeName }} New() => new(System.Guid.NewGuid());

    public override string ToString() => $"{{ TypeName }}:{Value}";
}
```

!!! note "Auto-discovery"
    Templates are automatically discovered via the `buildTransitive/.targets` file shipped with `Deepstaging.Roslyn.Scriban`. Files matching `Templates/**/*.scriban-cs` are passed to the generator as `AdditionalTexts` — no manual csproj edits needed.

### Using the scaffold code fix

If a generator supports customizable templates, the **DSRK005** analyzer reports an informational diagnostic on types that can be customized:

> Type 'UserId' supports a customizable template 'Deepstaging.Ids/StrongId'. Add a template to override the default generated code.

Use the **code fix** (lightbulb action) to create a starter template pre-filled with the generator's default output, with bound values replaced by Scriban placeholders.

## Scaffold Analyzer

### DSRK005 — Customizable template available

| Property | Value |
|----------|-------|
| **ID** | DSRK005 |
| **Severity** | Info |
| **Category** | CodeGeneration |
| **Enabled** | Yes |

Reported when a type uses a trigger attribute that has a customizable template available, but no user template file has been created yet. The accompanying code fix creates the template file with scaffold content.

### How scaffold metadata works

Generators emit `[assembly: AssemblyMetadata]` attributes advertising available templates:

```csharp
[assembly: AssemblyMetadata("Deepstaging.Scaffold:MyProject/MyType", "MyProject.MyAttribute")]
[assembly: AssemblyMetadata("Deepstaging.Scaffold:MyProject/MyType:Content", @"// scaffold...")]
```

The analyzer reads these from the compilation, checks for matching template files in `AdditionalTexts`, and reports `DSRK005` for types with the trigger attribute but no template.

## API Reference

### TemplateMap&lt;TModel&gt;

| Member | Description |
|--------|-------------|
| `Bind<T>(value, selector)` | Pass-through that records the mapping. Returns `value` unchanged. |
| `Bindings` | `IReadOnlyList<TemplateBinding>` of recorded mappings. |

### CustomizableEmit

| Member | Description |
|--------|-------------|
| `DefaultEmit` | The `OptionalEmit` fallback when no user template exists. |
| `TemplateName` | Namespaced template name (e.g., `"Deepstaging.Ids/StrongId"`). |
| `Model` | Object used for template rendering. |
| `Bindings` | Property bindings from `TemplateMap<T>`. |
| `ResolveFrom(templates)` | Returns user template result or default emit. |
| `AddSourceTo(ctx, filename, templates)` | Resolves and adds to source output. |

### UserTemplatesExtensions

| Member | Description |
|--------|-------------|
| `context.UserTemplatesProvider` | `IncrementalValueProvider<UserTemplates>` from `AdditionalTexts`. |

### ScaffoldEmitter

| Member | Description |
|--------|-------------|
| `EmitScaffold(ctx, customizable, triggerAttrFQN)` | Emits `AssemblyMetadata` with scaffold content. |

### TemplateScaffold

| Member | Description |
|--------|-------------|
| `Generate(customizable)` | Creates scaffold by replacing bound values with `{{ PropertyPath }}` placeholders. |
