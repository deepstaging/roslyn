# Emit

Fluent builders for generating compilable C# code.

> **See also:** [Queries](Queries.md) | [Projections](Projections.md) | [Extensions](Extensions.md) | [Roslyn Toolkit README](../README.md)

## Overview

Emit builders construct Roslyn syntax trees using a fluent, immutable API. Where queries find code, emit builders create it.

| Builder | Purpose |
|---------|---------|
| `TypeBuilder` | Create classes, interfaces, structs, records |
| `MethodBuilder` | Create methods |
| `PropertyBuilder` | Create properties |
| `FieldBuilder` | Create fields |
| `ConstructorBuilder` | Create constructors |
| `ParameterBuilder` | Create parameters |
| `TypeParameterBuilder` | Create generic type parameters |
| `BodyBuilder` | Create method/property bodies |
| `AttributeBuilder` | Create attributes |
| `XmlDocumentationBuilder` | Create XML doc comments |

All builders are **immutable** — each method returns a new instance.

```csharp
var result = TypeBuilder
    .Class("Customer")
    .InNamespace("MyApp.Domain")
    .AsPartial()
    .AddProperty("Name", "string", p => p
        .WithAccessibility(Accessibility.Public)
        .WithAutoPropertyAccessors())
    .Emit();

if (result.IsValid(out var valid))
{
    string code = valid.Code;                    // Formatted C# code
    CompilationUnitSyntax syntax = valid.Syntax; // Roslyn syntax tree
}
```

---

## TypeBuilder

Create type declarations.

### Factory Methods

| Method | Description |
|--------|-------------|
| `Class(string name)` | Create a class |
| `Interface(string name)` | Create an interface |
| `Struct(string name)` | Create a struct |
| `Record(string name)` | Create a record |
| `Parse(string signature)` | Parse from signature (e.g., `"public partial class MyClass"`) |

### Namespace & Usings

```csharp
TypeBuilder
    .Class("MyClass")
    .InNamespace("MyApp.Domain")
    .AddUsing("System")
    .AddUsings("System.Collections.Generic", "System.Linq")
```

### Accessibility & Modifiers

```csharp
TypeBuilder
    .Class("MyClass")
    .WithAccessibility(Accessibility.Public)
    .AsStatic()
    .AsAbstract()
    .AsSealed()
    .AsPartial()
```

### Interfaces

```csharp
TypeBuilder
    .Class("Repository")
    .Implements("IRepository")
    .Implements("IDisposable", "IAsyncDisposable")
```

### Adding Members

```csharp
// Properties
builder.AddProperty("Name", "string", prop => prop
    .WithAccessibility(Accessibility.Public)
    .WithAutoPropertyAccessors())
builder.AddProperty(propertyBuilder)

// Fields
builder.AddField("_name", "string", field => field
    .WithAccessibility(Accessibility.Private)
    .AsReadonly())
builder.AddField(fieldBuilder)

// Methods
builder.AddMethod("GetName", method => method
    .WithReturnType("string")
    .WithBody(body => body.AddReturn("_name")))
builder.AddMethod(methodBuilder)

// Constructors
builder.AddConstructor(ctor => ctor
    .AddParameter("name", "string")
    .WithBody(body => body.AddStatement("_name = name;")))
builder.AddConstructor(constructorBuilder)

// Primary constructors (records, C# 12+)
builder.WithPrimaryConstructor(ctor => ctor
    .AddParameter("name", "string"))

// Nested types
builder.AddNestedType("Inner", inner => inner
    .WithAccessibility(Accessibility.Private))
builder.AddNestedType(nestedTypeBuilder)
```

### Attributes

```csharp
builder.WithAttribute("Serializable")
builder.WithAttribute("JsonProperty", attr => attr
    .WithArgument("\"name\"")
    .WithNamedArgument("Required", "true"))
builder.WithAttribute(attributeBuilder)
```

### XML Documentation

```csharp
builder.WithXmlDoc("Represents a customer entity.")

builder.WithXmlDoc(doc => doc
    .Summary("Represents a customer entity.")
    .Remarks("This class is generated by the source generator."))

builder.WithXmlDoc(existingXmlDocumentation)
```

### Properties

```csharp
builder.Name    // string — the type name
builder.Kind    // TypeKind — class, interface, struct, etc.
```

### Emit

```csharp
OptionalEmit result = builder.Emit();
OptionalEmit result = builder.Emit(EmitOptions.Default);
```

---

## MethodBuilder

Create method declarations.

### Factory Methods

| Method | Description |
|--------|-------------|
| `For(string name)` | Create a method with the given name |
| `Parse(string signature)` | Parse from signature (e.g., `"public async Task<int> GetCount()"`) |

### Return Type

```csharp
method.WithReturnType("void")
method.WithReturnType("string")
method.WithReturnType("Task<int>")
method.WithReturnType("IAsyncEnumerable<Order>")
```

### Accessibility & Modifiers

```csharp
method.WithAccessibility(Accessibility.Public)
method.AsStatic()
method.AsVirtual()
method.AsOverride()
method.AsAbstract()
method.Async()
```

### Type Parameters

```csharp
method.AddTypeParameter("T")
method.AddTypeParameter("T", tp => tp
    .AsClass()
    .WithNewConstraint())
method.AddTypeParameter(typeParameterBuilder)
```

### Parameters

```csharp
method.AddParameter("name", "string")
method.AddParameter("count", "int", p => p.WithDefaultValue("0"))
method.AddParameter(parameterBuilder)
```

### Body

```csharp
// Block body
method.WithBody(body => body
    .AddStatement("Console.WriteLine(\"Starting\");")
    .AddStatement("DoWork();")
    .AddReturn("result"))

// Expression body
method.WithExpressionBody("_name")

// Append to expression body
method.AppendExpressionBody(".ToList()")
```

### Attributes & XML Documentation

```csharp
method.WithAttribute("HttpGet")
method.WithAttribute("Route", attr => attr.WithArgument("\"/api/items\""))

method.WithXmlDoc("Gets the customer name.")
method.WithXmlDoc(doc => doc
    .Summary("Gets a customer by identifier.")
    .Param("id", "The customer identifier.")
    .Returns("The customer if found; otherwise, null."))
```

### Usings

```csharp
method.AddUsing("System.Linq")
method.AddUsings("System", "System.Threading.Tasks")
```

### Properties

```csharp
method.Name             // string
method.ReturnType       // string?
method.ExtensionTargetType // string? — the type being extended (for extension methods)
```

---

## PropertyBuilder

Create property declarations.

### Factory Methods

| Method | Description |
|--------|-------------|
| `For(string name, string type)` | Create a property |
| `Parse(string signature)` | Parse from signature (e.g., `"public string Name { get; set; }"`) |

### Accessor Styles

```csharp
// Auto-property { get; set; }
prop.WithAutoPropertyAccessors()

// Read-only auto-property { get; }
prop.WithAutoPropertyAccessors().AsReadOnly()

// Expression-bodied getter => expression
prop.WithGetter("_name")
prop.WithGetter("=> _name")  // "=>" is optional

// Block-bodied getter
prop.WithGetter(body => body
    .AddStatement("if (_name == null) _name = LoadName();")
    .AddReturn("_name"))

// Block-bodied setter
prop.WithSetter(body => body
    .AddStatement("_name = value;")
    .AddStatement("OnPropertyChanged();"))
```

### Modifiers

```csharp
prop.WithAccessibility(Accessibility.Public)
prop.AsStatic()
prop.AsVirtual()
prop.AsOverride()
prop.AsAbstract()
prop.AsReadOnly()  // removes setter
```

### Initialization

```csharp
prop.WithInitializer("new()")
prop.WithInitializer("default")
prop.WithInitializer("\"Default Value\"")
prop.WithBackingField("_name")  // references a backing field
```

### Attributes & XML Documentation

```csharp
prop.WithAttribute("JsonProperty")
prop.WithXmlDoc("Gets or sets the customer name.")
```

### Usings

```csharp
prop.AddUsing("System.Text.Json.Serialization")
```

### Properties

```csharp
prop.Name   // string
prop.Type   // string
```

---

## FieldBuilder

Create field declarations.

### Factory Methods

| Method | Description |
|--------|-------------|
| `For(string name, string type)` | Create a field |
| `Parse(string signature)` | Parse from signature |

### Modifiers

```csharp
field.WithAccessibility(Accessibility.Private)
field.AsStatic()
field.AsReadonly()
field.AsConst()
```

### Initialization

```csharp
field.WithInitializer("string.Empty")
field.WithInitializer("42")
```

### Attributes & XML Documentation

```csharp
field.WithAttribute("NonSerialized")
field.WithXmlDoc("The backing field for Name.")
```

### Usings

```csharp
field.AddUsing("System")
```

### Properties

```csharp
field.Name   // string
field.Type   // string
```

---

## ConstructorBuilder

Create constructor declarations.

### Factory Methods

| Method | Description |
|--------|-------------|
| `For(string typeName)` | Create a constructor for the given type |

### Modifiers

```csharp
ctor.WithAccessibility(Accessibility.Public)
ctor.AsStatic()
ctor.AsPrimary()  // for primary constructors
```

### Parameters

```csharp
ctor.AddParameter("name", "string")
ctor.AddParameter("email", "string", p => p.WithDefaultValue("null"))
ctor.AddParameter(parameterBuilder)
```

### Body

```csharp
ctor.WithBody(body => body
    .AddStatement("Name = name;")
    .AddStatement("Email = email;"))
```

### Constructor Chaining

```csharp
ctor.CallsBase("name", "email")  // : base(name, email)
ctor.CallsThis("name")           // : this(name)
```

### Attributes & XML Documentation

```csharp
ctor.WithAttribute("Obsolete")
ctor.WithXmlDoc("Initializes a new instance of the Customer class.")
```

### Properties

```csharp
ctor.IsPrimary      // bool
ctor.Parameters     // ImmutableArray<ParameterBuilder>
ctor.Usings         // ImmutableArray<string>
```

---

## ParameterBuilder

Create parameter declarations.

### Factory Methods

| Method | Description |
|--------|-------------|
| `For(string name, string type)` | Create a parameter |

### Configuration

```csharp
param.WithDefaultValue("0")
param.WithDefaultValue("\"default\"")
param.AsRef()
param.AsOut()
param.AsIn()
param.AsParams()
param.AsThis()  // for extension method target
```

### Properties

```csharp
param.Name              // string
param.Type              // string
param.IsExtensionTarget // bool
```

---

## TypeParameterBuilder

Create generic type parameter declarations.

### Factory Methods

| Method | Description |
|--------|-------------|
| `For(string name)` | Create a type parameter |

### Constraints

```csharp
tp.WithConstraint("IDisposable")
tp.AsClass()       // where T : class
tp.AsStruct()      // where T : struct
tp.AsNotNull()     // where T : notnull
tp.WithNewConstraint()  // where T : new()
```

### Properties

```csharp
tp.Name           // string
tp.HasConstraints // bool
```

---

## BodyBuilder

Build method and property bodies.

### Factory Methods

| Method | Description |
|--------|-------------|
| `Empty()` | Create an empty body |

### Adding Statements

```csharp
body.AddStatement("Console.WriteLine(\"Hello\");")
body.AddStatements("var a = 1;\nvar b = 2;")  // multi-line string
body.AddReturn("result")
body.AddReturn()  // void return
body.AddThrow("new InvalidOperationException()")
body.AddCustom(statementSyntax)  // raw Roslyn syntax
```

### Properties

```csharp
body.IsEmpty  // bool
```

---

## AttributeBuilder

Create attribute declarations.

### Factory Methods

| Method | Description |
|--------|-------------|
| `For(string name)` | Create an attribute |

### Arguments

```csharp
attr.WithArgument("\"value\"")
attr.WithArguments("1", "2", "3")
attr.WithNamedArgument("Name", "\"value\"")
```

### Usings

```csharp
attr.AddUsing("System.ComponentModel")
```

### Properties

```csharp
attr.Name    // string
attr.Usings  // ImmutableArray<string>
```

---

## XmlDocumentationBuilder

Create XML documentation comments.

### Factory Methods

| Method | Description |
|--------|-------------|
| `Create()` | Create empty documentation |
| `WithSummary(string)` | Create with just a summary |
| `From(XmlDocumentation)` | Create from existing parsed documentation |

### Content

```csharp
doc.Summary("Gets the customer name.")
doc.Remarks("This method queries the database.")
doc.Returns("The customer name if found; otherwise, null.")
doc.Value("The property value.")
doc.Param("id", "The customer identifier.")
doc.TypeParam("T", "The entity type.")
doc.Exception("InvalidOperationException", "Thrown when...")
doc.SeeAlso("OtherClass")
doc.Example("<code>var name = GetName(123);</code>")
```

### Properties

```csharp
doc.HasContent  // bool
```

---

## EmitOptions

Configure code emission.

### Properties

| Property | Type | Description |
|----------|------|-------------|
| `ValidationLevel` | `ValidationLevel` | None, Syntax, Semantic, Full |
| `Indentation` | `string` | Indentation string (default: 4 spaces) |
| `EndOfLine` | `string` | Line ending (default: `\n`) |
| `HeaderComment` | `string` | Comment at top of file |
| `LicenseHeader` | `string?` | License header text |

### Static Instances

```csharp
EmitOptions.Default      // syntax validation, standard formatting
EmitOptions.NoValidation // skip validation
```

### Usage

```csharp
var options = EmitOptions.Default with
{
    ValidationLevel = ValidationLevel.Semantic,
    HeaderComment = "// Auto-generated"
};

var result = builder.Emit(options);
```

### ValidationLevel Enum

| Value | Description |
|-------|-------------|
| `None` | No validation |
| `Syntax` | Syntax validation only (default) |
| `Semantic` | Semantic validation (requires compilation) |
| `Full` | Full validation |

---

## OptionalEmit

The result of emitting code.

```csharp
var result = builder.Emit();

// Check if valid
if (result.IsValid(out var valid))
{
    string code = valid.Code;                    // Formatted C# code
    CompilationUnitSyntax syntax = valid.Syntax; // Roslyn syntax tree
}

// Check if invalid
if (result.IsNotValid(out var diagnostics))
{
    foreach (var diagnostic in diagnostics)
    {
        Console.WriteLine(diagnostic.GetMessage());
    }
}

// Get diagnostics (warnings even if valid)
ImmutableArray<Diagnostic> diags = result.Diagnostics;
```

---

## Complete Example

```csharp
var result = TypeBuilder
    .Class("CustomerRepository")
    .InNamespace("MyApp.Data")
    .AddUsing("System")
    .AddUsing("System.Threading.Tasks")
    .Implements("ICustomerRepository")
    .WithXmlDoc("Repository for customer data access.")
    .AddField("_context", "DbContext", f => f
        .WithAccessibility(Accessibility.Private)
        .AsReadonly())
    .AddConstructor(ctor => ctor
        .WithAccessibility(Accessibility.Public)
        .AddParameter("context", "DbContext")
        .WithBody(body => body.AddStatement("_context = context;")))
    .AddMethod("GetByIdAsync", m => m
        .WithReturnType("Task<Customer?>")
        .WithAccessibility(Accessibility.Public)
        .Async()
        .AddParameter("id", "Guid")
        .AddParameter("cancellationToken", "CancellationToken", p => p.WithDefaultValue("default"))
        .WithXmlDoc(doc => doc
            .Summary("Gets a customer by identifier.")
            .Param("id", "The customer identifier.")
            .Param("cancellationToken", "Cancellation token.")
            .Returns("The customer if found; otherwise, null."))
        .WithBody(body => body
            .AddReturn("await _context.Customers.FindAsync(new object[] { id }, cancellationToken)")))
    .Emit();

if (result.IsValid(out var valid))
{
    context.AddSource("CustomerRepository.g.cs", valid.Code);
}
```

---

## Real-World Usage

### Generating from Analyzed Symbols

```csharp
// Generate a module class from analyzed type information
return TypeBuilder.Parse($"public static partial class {model.EffectsContainerName}")
    .AddUsings(usings)
    .InNamespace(model.Namespace)
    .AddNestedType(module)
    .Emit(options ?? EmitOptions.Default);
```

### Adding Methods Dynamically

```csharp
var builder = TypeBuilder.Class("Generated");

foreach (var method in methods)
{
    builder = builder.AddMethod(method.Name, m => m
        .AsStatic()
        .WithReturnType($"Eff<RT, {method.ReturnType}>")
        .AddParameter("input", method.InputType)
        .WithXmlDoc(method.XmlDocumentation)
        .WithExpressionBody(GenerateBody(method)));
}
```

### Using Parse for Complex Signatures

```csharp
// Parse handles complex signatures more naturally
var method = MethodBuilder.Parse("public async Task<IEnumerable<Customer>> GetAllAsync()")
    .AddParameter("filter", "CustomerFilter", p => p.WithDefaultValue("null"))
    .WithBody(body => body
        .AddStatement("var query = _context.Customers.AsQueryable();")
        .AddStatement("if (filter != null) query = query.Where(filter.ToPredicate());")
        .AddReturn("await query.ToListAsync()"));
```

## License

**RPL-1.5** (Reciprocal Public License) — Real reciprocity, no loopholes.

You can use this code, modify it, and share it freely. But when you deploy it — internally or externally, as a service or within your company — you share your improvements back under the same license.

Why? We believe if you benefit from this code, the community should benefit from your improvements. That's the deal we think is fair.

**Personal research and experimentation? No obligations.** Go learn, explore, and build.

See [LICENSE](../../../LICENSE) for the full legal text.
